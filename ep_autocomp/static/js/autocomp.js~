var underscore = require('ep_etherpad-lite/static/js/underscore');
var $ = require('ep_etherpad-lite/static/js/rjquery').$; //it rjquery is a bridge in order to make jquery require-able


/*
This must be changed as we want to disable calling the plugin, not showing something. 

$('#taglistButton').click(function(){
  $('#taglist').toggle();
});
*/
var autocomp = {
	//the following shoould probably be: isActive(true) for enabling, isActive (false) for disabling, isActive() for getting the current state. (closure!)
	isEnabled: true,//this could be getter/Setter too
	isShown: false,
	enable: function(){ //show suggenstions
		
	},

	disable: function(){//hide suggestions
		
	},
	
	showAutocomp:function(){
		//determine position
		
		//fill in list
		
	
	},
	hideAutocomp:function(){},
	aceKeyEvent: function(type, context, cb){
		//if not menu not shown, dont prevent defaults
		
		//if key is ↑ , choose next option, prevent default
		//if key is ↓ , choose next option, prevent default
		//if key is ENTER, read out the complementation, close autocomplete menu and input it at cursor
		
		
		
		
		if(context.evt.which===89 && autocomp.isEnabled===true)
		{
			var curEl = context.rep.lines.atIndex(context.rep.selEnd[0]).lineNode;

			//$(curEl).sendkeys('he ho I pressed Y!');

			autocomp.isEnabled = false;
			window.setTimeout(function(){autocomp.isEnabled=true; console.log("reenabled");},1000);
			context.evt.preventDefault();
			return true; // returnvalue should be true if the event was handled. So we return a true which can be returned by the hook itself consequently. A bit FUD here. 
		}
	},
	aceEditEvent:function(type, context, cb){ 
		//remove from here into checkForAutocomp or so. Usecase: use ←↓↑→ to navigate the code will not cause edit events. 
		if(context.rep.selStart === null){return;}
		if(autocomp.isEditByMe!==true){return}
		
		var sectionMarker= /[\S]*$/; //what is the  section to be considered? Usually, this will be everything which is not a space. The Regex includes the $ (end of line) so we can find the section of interest beginning form the strings end. (To understand better, just paste into regexpal.com) 
		var afterSectionMarker = /^$|^\s/ //what is the section after the caret in order to allow autocompletion? Usually we don’t want to start autocompletion directly in a word, so we restrict it to either whitepsace \s or to an empty string, ^$. Not this applies the the string after the caret (hence the start of string at the beginning, ^)
		
		var caretPosition = context.rep.selEnd; //TODO: must it be the same as selStart to be viable? FUD-test on equivalence?
		var currentLine = context.rep.lines.atIndex(caretPosition[0]); //gets infos about the line the caret is in 
		var textBeforeCaret = currentLine.text.slice(0,caretPosition[1]); //from beginning until caret
		//var charAfterCaret = currentLine.text.charAt(caretPosition[1]); //returns the character after the caret
		var relevantSection = textBeforeCaret.match(sectionMarker)[0]; 
		
		
		if(!(relevantSection.length>0)){ //return if either the string in front or the string after the caret are not suitable. 
			return;
		}
		
		suggestions = autocomp.getPossibleSuggestions();
		filteredSuggestions = autocomp.filterSuggestionList(relevantSection, suggestions); //To be implemented
		autocomp.showAutocomp(filteredSuggestions);
	},
	filterSuggestionList:function(relevantSection,possibleSuggestions){
		/*
		gets: 
		- the string for which we want matches ("relevantSection")
		- a list of all completions
		
		returns: an array with objects containing suggestions as object with
		{
			fullText: string containing the full text, e.g. "nightingale"
			complementaryString: string with what is needed to complete the String to be matched e.g is the string to be matches is "nighti", than the complementary String here would be "ngale"
		}
		*/
		
		//filter it
		var filteredSuggestions=[];
		underscore.each(possibleSuggestions,function(possibleSuggestion, key, list){
			if(typeof possibleSuggestion !=="string"){return;} //precaution
			if(possibleSuggestion.indexOf(relevantSection)===0){ //indexOf === 0 means, in the possibleSuggestion is the (whole) relevant section and it starts at the begin of the possibleSuggestion 
				var complementaryString = possibleSuggestion.slice(relevantSection.length)
				filteredSuggestions.push({
				"fullText":possibleSuggestion, 
				"complementaryString":complementaryString});
			}
		});
		
		var filteredSuggestionsSorted=underscore.sortBy(filteredSuggestions,function(suggestion){return suggestion.fullText}); 		   //sort suggestions by the fullText attribute
		//sort it (if the list remains static, this could be done only once
		
		//console.log(relevantSection,filteredSuggestionsSorted);
		return filteredSuggestionsSorted;
	},
	getParam: function(sname)
	{	/*
	for getting URL parameters
	sname is the requested key
	returned is the keys value

	so if you have http://www.someurl.end?foo=bar
	it will return "bar" if you give it "foo"
	*/
	var params = location.search.substr(location.search.indexOf("?")+1); //"?" devides the actual URL from the parameters
	var sval = "";
	params = params.split("&"); //"&" devides the kex/value pairs

	for (var i=0; i<params.length; i++)// split param and value into individual pieces
	{
	temp = params[i].split("=");
	if ( [temp[0]] == sname ) { sval = temp[1]; }
	}
	return sval;
	},
	
	isEditByMe:function(context){
		/*
		determines if the edit is done on the authors client or by a collaborator
		gets: context-objects
		returns: boolean. true (edit is done by author), false (edit done by someone else)
		*/
		if (!context||!context.callstack){return}
		if (context.callstack.editEvent.eventType==="idleWorkTimer"){ //this is the only way I found to determine if an edit is caused by input from the current user or from a collaborator
			return true
		}else{
			return false;
		}
	},
	getPossibleSuggestions:function(){
		return ["a", "ab", "abc", "abcd", "b", "bc", "bcd", "bcde"];
	}
	
};


